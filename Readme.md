# Fault-Sim – Memory Fault Simulator
  
A modular C++ simulator for evaluating **memory fault models** against **March-based test patterns**.  
It supports one-cell and two-cell faults, pluggable triggers, detailed detection reports, and batch execution
on CPU-only Docker containers or native builds via `make`.

---

## Table of Contents
- [Features](#features)
- [Project Layout](#project-layout)
- [Quick Start](#quick-start)
  - [1. Build the Docker image](#1-build-the-docker-image)
  - [2. Run a local simulation](#2-run-a-local-simulation)
  - [3. Run on an NFS mount (optional)](#3-run-on-an-nfs-mount-optional)
  - [4. Native build & make targets](#4-native-build--make-targets)
- [Input / Output](#input--output)
- [Extending the Simulator](#extending-the-simulator)
- [License](#license)
- [Acknowledgements](#acknowledgements)

---

## Features
| Category | Details |
| -------- | ------- |
| **Fault models** | Single-cell faults (`OneCellFault`) and coupled two-cell faults (`TwoCellFault`) with configurable stuck-at / value-dependent behavior |
| **Test patterns** | Arbitrary March sequences (ascending, descending, or mixed address walks) parsed from JSON |
| **Reporting** | Per-fault `DetectionReport` with victim addresses and March-operation granularity |
| **Reproducibility** | Deterministic address allocation (seeded RNG) and fully containerized build |
| **Extensibility** | Clean interfaces (`IFault`, `ITrigger`, `IFaultSimulator`, `IResultCollector`) for new fault types or collectors |

---

## Project Layout

```text
.
├── docker/               # Docker context
│   └── Dockerfile        # CentOS/Rocky Linux 8 image, toolchain + deps
├── include/              # (recommended) or project root for headers
│   ├── AddressAllocator.hpp
│   ├── DetectionReport.hpp
│   ├── Fault.hpp
│   ├── FaultConfig.hpp
│   ├── FaultSimulator.hpp
│   ├── March.hpp
│   ├── MemoryState.hpp
│   ├── Parser.hpp
│   ├── ResultCollector.hpp
│   └── SequenceExecutor.hpp
├── src/                  # <— ⚠️ IMPLEMENTATION *.cpp files should live here
│   └── (pending)
├── input/                # JSON test vectors (mounted read-only in Docker)
│   ├── Fault.json
│   └── March-LSD.json
├── output/               # Simulation reports (mounted read-write)
├── Makefile
└── README.md             # you-are-here

````

---

## Quick Start

### 1. Build the Docker image

```bash
docker build -t fault-sim:latest -f docker/Dockerfile .
```

### 2. Run a local simulation

```bash
# (Assumes input/ and output/ exist in the repo root)
docker run --rm \
  -v "$PWD/input":/input \
  -v "$PWD/output":/output \
  fault-sim:latest
```

### 3. Run on an NFS mount (optional)

```bash
# Example – adjust NFS IP / path as needed
sudo mount -t nfs 192.168.1.100:/export/projects /mnt/nfs_share

docker run --rm \
  -v /mnt/nfs_share/input:/input \
  -v /mnt/nfs_share/results:/output \
  fault-sim:latest
```

### 4. Native build & `make` targets

```bash
# Compile the simulator (makefile target 'com')
make com

# Run a simulation (makefile target 'run')
make run \
  FAULT=Fault.json \
  MARCH=March-LSD.json \
  OUTPUTFILE=March-LSD_detection_report.txt
```

`make run` passes the variables straight to the executable; feel free to
change paths or add new parameters in `Makefile`.

---

## Input / Output

| File               | Role                                                                                                                                             |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`Fault.json`**   | Array of fault objects – each entry maps to `FaultConfig` and may describe one-cell or two-cell scenarios.                                       |
| **`March-*.json`** | Array of March elements – parsed into `std::vector<MarchElement>` describing address order and per-operation tokens (`R0`, `W1`, `CI`, `CO`, …). |
| **`*.txt`**        | Plain-text detection report generated by `Parser::writeDetectionReport()`; contains pass/fail syndrome per fault plus overall coverage.          |

See `include/Parser.hpp` for detailed token grammar.

---

## Extending the Simulator

1. **Implement new fault physics**

   * Subclass `IFault`, create a corresponding `ITrigger`, and register it in `FaultFactory`.
2. **Alternate memory back-ends**

   * Derive from `MemoryState` for sparse or multi-bank layouts.
3. **Bulk result analysis**

   * Create a custom `IResultCollector`, e.g., to emit CSV or SQLite.

If you need example `.cpp` scaffolding for any of these classes, open an issue or ping me – happy to generate templates.

---

## Acknowledgements

This project was created by **\< Wei-Hung, Lin / NCU EDA LAB>** as part of ongoing research into
fault resilience of emerging memory technologies.  Contributions are welcome!

---

# 中文版（Traditional Chinese）

> *English version above* – 以下為中文說明。

## 專案簡介

**Fault-Sim** 是一套以 C++ 撰寫的 **記憶體錯誤模擬器**，可搭配
**March 測試序列** 評估一／二位元胞錯誤 (one-cell / two-cell fault) 的可偵測性，
並輸出詳細偵測報告。
專案提供 **Docker** 容器與 **Makefile** 兩種建置方式，方便在實驗室
或 CI/CD 環境中重現結果。

## 特色

* **錯誤模型**：支援單位元胞與耦合式兩位元胞錯誤，可設定 Stuck-At、值依賴 (value-dependent) 等多種情境
* **彈性測試序列**：March pattern 由 JSON 描述，可自由定義地址遞增／遞減順序
* **偵測報告**：輸出包含偵測位址、March 位置索引與整體覆蓋率
* **容器化**：Rocky Linux 8 映像檔內建 GCC／Make，可即刻執行
* **擴充介面**：介面使用純虛類別 (`IFault`、`ITrigger` ...)，便於後續研究加入新模型

## 專案結構

```
include/   → 公用標頭檔 (*.hpp)
src/       → ⚠️ 需自行補上對應 *.cpp
input/     → 測試向量 (Fault.json, March-*.json)
output/    → 偵測結果
docker/    → Dockerfile
Makefile   → 編譯／執行目標
```

## 快速開始

### 1. 建立 Docker 映像檔

```bash
docker build -t fault-sim:latest -f docker/Dockerfile .
```

### 2. 本機執行

```bash
docker run --rm \
  -v "$PWD/input":/input \
  -v "$PWD/output":/output \
  fault-sim:latest
```

### 3. 透過 NFS 執行（範例，請依實際環境調整）

```bash
sudo mount -t nfs 192.168.1.100:/export/projects /mnt/nfs_share

docker run --rm \
  -v /mnt/nfs_share/input:/input \
  -v /mnt/nfs_share/results:/output \
  fault-sim:latest
```

### 4. 使用 Makefile

```bash
make com                       # 編譯
make run FAULT=Fault.json \
         MARCH=March-LSD.json \
         OUTPUTFILE=March-LSD_detection_report.txt
```

## 輸入 / 輸出格式

| 檔案                | 說明                                       |
| ----------------- | ---------------------------------------- |
| **Fault.json**    | 對應 `FaultConfig`；描述每個錯誤之型態、初值、觸發序列等      |
| **March-\*.json** | 對應 `MarchElement`；描述 March 元件與位址遞增/遞減方向  |
| **\*.txt**        | `Parser::writeDetectionReport()` 產生之偵測報告 |

